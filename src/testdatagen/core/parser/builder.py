








from typing import Dict, List, Optional, Any, Union
from antlr4 import InputStream, CommonTokenStream, ParserRuleContext
from antlr4.tree.Tree import ParseTree

# These will be generated by ANTLR
from .generated.TestDataGenLexer import TestDataGenLexer
from .generated.TestDataGenParser import TestDataGenParser
from .generated.TestDataGenVisitor import TestDataGenVisitor

from ..ast.nodes import (
    ASTNode, SchemaNode, TableNode, FieldNode, ConstraintNode, 
    NodeType
)


class ASTBuilder(TestDataGenVisitor):
    """Builds an AST from an ANTLR parse tree"""
    
    def __init__(self):
        super().__init__()
    
    def build(self, input_stream: InputStream) -> SchemaNode:
        """Build an AST from an input stream"""
        # This method is no longer used directly
        # The parsing is now done in the Parser._parse method
        # This is kept for backward compatibility
        from .error_listener import TestDataGenErrorListener
        error_listener = TestDataGenErrorListener()
        
        lexer = TestDataGenLexer(input_stream)
        lexer.removeErrorListeners()
        lexer.addErrorListener(error_listener)
        
        token_stream = CommonTokenStream(lexer)
        parser = TestDataGenParser(token_stream)
        parser.removeErrorListeners()
        parser.addErrorListener(error_listener)
        
        parse_tree = parser.program()
        return self.visit(parse_tree)
    
    def visitProgram(self, ctx: TestDataGenParser.ProgramContext) -> SchemaNode:
        """Visit a program node"""
        # Get the schema declaration
        schema_ctx = ctx.schemaDeclaration()
        
        # Get imports
        imports = []
        for import_ctx in ctx.importDeclaration():
            imports.append(self.visitImportDeclaration(import_ctx))
        
        # Visit the schema
        schema = self.visitSchemaDeclaration(schema_ctx)
        schema.imports = imports
        
        return schema
    
    def visitImportDeclaration(self, ctx: TestDataGenParser.ImportDeclarationContext) -> str:
        """Visit an import declaration"""
        # Extract the import path from the string literal
        import_path = ctx.STRING_LITERAL().getText()
        # Remove quotes
        import_path = import_path[1:-1]
        
        # Check for alias
        if ctx.AS() and ctx.ID():
            alias = ctx.ID().getText()
            return f"{import_path} as {alias}"
        
        return import_path
    
    def visitSchemaDeclaration(self, ctx: TestDataGenParser.SchemaDeclarationContext) -> SchemaNode:
        """Visit a schema declaration"""
        # Get the schema name
        if ctx.ID():
            schema_name = ctx.ID().getText()
        elif ctx.STRING_LITERAL():
            # Remove quotes from string literal
            schema_name = ctx.STRING_LITERAL().getText()[1:-1]
        else:
            schema_name = "DefaultSchema"
        
        # Get the tables
        tables = []
        for table_ctx in ctx.tableDeclaration():
            tables.append(self.visitTableDeclaration(table_ctx))
        
        return SchemaNode(
            node_type=NodeType.SCHEMA,
            name=schema_name,
            tables=tables,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitTableDeclaration(self, ctx: TestDataGenParser.TableDeclarationContext) -> TableNode:
        """Visit a table declaration"""
        # Get the table name
        table_name = ctx.ID().getText()
        
        # Get the fields
        fields = []
        for field_ctx in ctx.fieldDeclaration():
            fields.append(self.visitFieldDeclaration(field_ctx))
        
        # Get the constraints
        constraints = []
        for constraint_ctx in ctx.tableConstraint():
            constraints.append(self.visitTableConstraint(constraint_ctx))
        
        return TableNode(
            node_type=NodeType.TABLE,
            name=table_name,
            fields=fields,
            constraints=constraints,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitFieldDeclaration(self, ctx: TestDataGenParser.FieldDeclarationContext) -> FieldNode:
        """Visit a field declaration"""
        # Get the field name
        field_name = ctx.ID().getText()
        
        # Get the data type
        data_type = self.visitDataType(ctx.dataType())
        
        # Get modifiers
        nullable = True
        default_value = None
        
        for modifier_ctx in ctx.fieldModifier():
            if modifier_ctx.NULL():
                nullable = True
            elif modifier_ctx.NOT_NULL():
                nullable = False
            elif modifier_ctx.DEFAULT():
                default_value = self.visitDefaultValue(modifier_ctx.defaultValue())
        
        # Get constraints
        constraints = []
        for constraint_ctx in ctx.fieldConstraint():
            constraints.append(self.visitFieldConstraint(constraint_ctx))
        
        return FieldNode(
            node_type=NodeType.FIELD,
            name=field_name,
            data_type=data_type,
            nullable=nullable,
            default_value=default_value,
            constraints=constraints,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitDataType(self, ctx: TestDataGenParser.DataTypeContext) -> str:
        """Visit a data type"""
        if ctx.primitiveType():
            return self.visitPrimitiveType(ctx.primitiveType())
        elif ctx.complexType():
            return self.visitComplexType(ctx.complexType())
        else:
            # Custom type reference
            return ctx.ID().getText()
    
    def visitPrimitiveType(self, ctx: TestDataGenParser.PrimitiveTypeContext) -> str:
        """Visit a primitive type"""
        # Return the text of the primitive type
        return ctx.getText()
    
    def visitComplexType(self, ctx: TestDataGenParser.ComplexTypeContext) -> str:
        """Visit a complex type"""
        # Get the base type
        base_type = self.visitPrimitiveType(ctx.primitiveType())
        
        # Check for array size
        if ctx.INT_LITERAL():
            size = ctx.INT_LITERAL().getText()
            return f"{base_type}[{size}]"
        else:
            return f"{base_type}[]"
    
    def visitDefaultValue(self, ctx: TestDataGenParser.DefaultValueContext) -> Any:
        """Visit a default value"""
        if ctx.literal():
            return self.visitLiteral(ctx.literal())
        else:
            # Function call
            return self.visitFunctionCall(ctx.functionCall())
    
    def visitLiteral(self, ctx: TestDataGenParser.LiteralContext) -> Any:
        """Visit a literal"""
        if ctx.INT_LITERAL():
            return int(ctx.INT_LITERAL().getText())
        elif ctx.DECIMAL_LITERAL():
            return float(ctx.DECIMAL_LITERAL().getText())
        elif ctx.STRING_LITERAL():
            # Remove quotes
            return ctx.STRING_LITERAL().getText()[1:-1]
        elif ctx.TRUE():
            return True
        elif ctx.FALSE():
            return False
        elif ctx.NULL():
            return None
        elif ctx.arrayLiteral():
            return self.visitArrayLiteral(ctx.arrayLiteral())
        elif ctx.objectLiteral():
            return self.visitObjectLiteral(ctx.objectLiteral())
    
    def visitArrayLiteral(self, ctx: TestDataGenParser.ArrayLiteralContext) -> List[Any]:
        """Visit an array literal"""
        values = []
        for literal_ctx in ctx.literal():
            values.append(self.visitLiteral(literal_ctx))
        return values
    
    def visitObjectLiteral(self, ctx: TestDataGenParser.ObjectLiteralContext) -> Dict[str, Any]:
        """Visit an object literal"""
        obj = {}
        for field_ctx in ctx.objectField():
            field_name = field_ctx.ID().getText()
            field_value = self.visitLiteral(field_ctx.literal())
            obj[field_name] = field_value
        return obj
    
    def visitFunctionCall(self, ctx: TestDataGenParser.FunctionCallContext) -> Dict[str, Any]:
        """Visit a function call"""
        function_name = ctx.ID().getText()
        
        # Get arguments
        args = []
        if ctx.functionArgs():
            for arg_ctx in ctx.functionArgs().functionArg():
                args.append(self.visitExpression(arg_ctx.expression()))
        
        return {
            "function": function_name,
            "args": args
        }
    
    def visitExpression(self, ctx: TestDataGenParser.ExpressionContext) -> Any:
        """Visit an expression"""
        # This is a simplified implementation
        # In a real implementation, we would build an expression tree
        
        # For now, just return a placeholder
        return {"expression": ctx.getText()}
    
    def visitFieldConstraint(self, ctx: TestDataGenParser.FieldConstraintContext) -> ConstraintNode:
        """Visit a field constraint"""
        constraint_expr = self.visitConstraintExpression(ctx.constraintExpression())
        
        return ConstraintNode(
            node_type=NodeType.CONSTRAINT,
            name=constraint_expr.get("name", "unnamed_constraint"),
            constraint_type=constraint_expr.get("type", "unknown"),
            parameters=constraint_expr.get("parameters", {}),
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitTableConstraint(self, ctx: TestDataGenParser.TableConstraintContext) -> ConstraintNode:
        """Visit a table constraint"""
        # Get constraint name if provided
        constraint_name = "unnamed_constraint"
        if ctx.ID():
            constraint_name = ctx.ID().getText()
        
        constraint_expr = self.visitConstraintExpression(ctx.constraintExpression())
        
        return ConstraintNode(
            node_type=NodeType.CONSTRAINT,
            name=constraint_name,
            constraint_type=constraint_expr.get("type", "unknown"),
            parameters=constraint_expr.get("parameters", {}),
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitConstraintExpression(self, ctx: TestDataGenParser.ConstraintExpressionContext) -> Dict[str, Any]:
        """Visit a constraint expression"""
        if ctx.primaryKeyConstraint():
            return self.visitPrimaryKeyConstraint(ctx.primaryKeyConstraint())
        elif ctx.foreignKeyConstraint():
            return self.visitForeignKeyConstraint(ctx.foreignKeyConstraint())
        elif ctx.uniqueConstraint():
            return self.visitUniqueConstraint(ctx.uniqueConstraint())
        elif ctx.checkConstraint():
            return self.visitCheckConstraint(ctx.checkConstraint())
        else:
            return {"type": "unknown"}
    
    def visitPrimaryKeyConstraint(self, ctx: TestDataGenParser.PrimaryKeyConstraintContext) -> Dict[str, Any]:
        """Visit a primary key constraint"""
        fields = self.visitIdList(ctx.idList())
        
        return {
            "type": "primary_key",
            "parameters": {
                "fields": fields
            }
        }
    
    def visitForeignKeyConstraint(self, ctx: TestDataGenParser.ForeignKeyConstraintContext) -> Dict[str, Any]:
        """Visit a foreign key constraint"""
        source_fields = self.visitIdList(ctx.idList(0))
        target_table = ctx.ID().getText()
        target_fields = self.visitIdList(ctx.idList(1))
        
        return {
            "type": "foreign_key",
            "parameters": {
                "source_fields": source_fields,
                "target_table": target_table,
                "target_fields": target_fields
            }
        }
    
    def visitUniqueConstraint(self, ctx: TestDataGenParser.UniqueConstraintContext) -> Dict[str, Any]:
        """Visit a unique constraint"""
        fields = self.visitIdList(ctx.idList())
        
        return {
            "type": "unique",
            "parameters": {
                "fields": fields
            }
        }
    
    def visitCheckConstraint(self, ctx: TestDataGenParser.CheckConstraintContext) -> Dict[str, Any]:
        """Visit a check constraint"""
        expression = self.visitExpression(ctx.expression())
        
        return {
            "type": "check",
            "parameters": {
                "expression": expression
            }
        }
    
    def visitIdList(self, ctx: TestDataGenParser.IdListContext) -> List[str]:
        """Visit an ID list"""
        return [id_node.getText() for id_node in ctx.ID()]








