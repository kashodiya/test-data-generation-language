from typing import Dict, List, Optional, Any, Union
from antlr4 import InputStream, CommonTokenStream, ParserRuleContext
from antlr4.tree.Tree import ParseTree

# These will be generated by ANTLR
from .generated.TestDataGenLexer import TestDataGenLexer
from .generated.TestDataGenParser import TestDataGenParser
from .generated.TestDataGenVisitor import TestDataGenVisitor

from ..ast.nodes import (
    ASTNode, SchemaNode, TableNode, FieldNode, ConstraintNode, TypeNode,
    NodeType
)


class ASTBuilder(TestDataGenVisitor):
    """Builds an AST from an ANTLR parse tree"""
    
    def __init__(self):
        super().__init__()
    
    def build(self, input_stream: InputStream) -> SchemaNode:
        """Build an AST from an input stream"""
        # This method is no longer used directly
        # The parsing is now done in the Parser._parse method
        # This is kept for backward compatibility
        from .error_listener import TestDataGenErrorListener
        error_listener = TestDataGenErrorListener()
        
        lexer = TestDataGenLexer(input_stream)
        lexer.removeErrorListeners()
        lexer.addErrorListener(error_listener)
        
        token_stream = CommonTokenStream(lexer)
        parser = TestDataGenParser(token_stream)
        parser.removeErrorListeners()
        parser.addErrorListener(error_listener)
        
        parse_tree = parser.program()
        return self.visit(parse_tree)
    
    def visitProgram(self, ctx: TestDataGenParser.ProgramContext) -> SchemaNode:
        """Visit a program node"""
        # Get the schema declaration
        schema_ctx = ctx.schemaDeclaration()
        print(f"Schema context: {schema_ctx}")
        
        # Debug the schema context
        if schema_ctx:
            print(f"Schema context type: {type(schema_ctx)}")
            print(f"Schema context dir: {dir(schema_ctx)}")
            if hasattr(schema_ctx, 'tableDeclaration'):
                print(f"Table declarations: {schema_ctx.tableDeclaration()}")
                print(f"Number of table declarations: {len(schema_ctx.tableDeclaration())}")
                for i, table_ctx in enumerate(schema_ctx.tableDeclaration()):
                    print(f"Table declaration {i}: {table_ctx}")
            else:
                print("Schema context has no tableDeclaration attribute")
        else:
            print("No schema context found")
        
        # Get imports
        imports = []
        for import_ctx in ctx.importDeclaration():
            imports.append(self.visitImportDeclaration(import_ctx))
        
        # Visit the schema
        schema = self.visitSchemaDeclaration(schema_ctx)
        schema.imports = imports
        
        print(f"Schema after visiting: {schema}")
        print(f"Schema tables: {schema.tables}")
        
        return schema
    
    def visitImportDeclaration(self, ctx: TestDataGenParser.ImportDeclarationContext) -> str:
        """Visit an import declaration"""
        # Extract the import path from the string literal
        import_path = ctx.STRING_LITERAL().getText()
        # Remove quotes
        import_path = import_path[1:-1]
        
        # Check for alias
        if ctx.AS() and ctx.ID():
            alias = ctx.ID().getText()
            return f"{import_path} as {alias}"
        
        return import_path
    
    def visitSchemaDeclaration(self, ctx: TestDataGenParser.SchemaDeclarationContext) -> SchemaNode:
        """Visit a schema declaration"""
        # Get the schema name
        if ctx and hasattr(ctx, 'ID') and ctx.ID():
            schema_name = ctx.ID().getText()
            # If the schema name is in quotes, remove them
            if schema_name.startswith('"') and schema_name.endswith('"'):
                schema_name = schema_name[1:-1]
        else:
            schema_name = "DefaultSchema"
        
        print(f"Schema name: {schema_name}")
        
        # Get the type declarations
        types = []
        if ctx and hasattr(ctx, 'typeDeclaration') and ctx.typeDeclaration():
            print(f"Number of type declarations: {len(ctx.typeDeclaration())}")
            for i, type_ctx in enumerate(ctx.typeDeclaration()):
                print(f"Type declaration {i}: {type_ctx}")
                type_node = self.visitTypeDeclaration(type_ctx)
                print(f"Processed type: {type_node}")
                types.append(type_node)
        else:
            print("No type declarations found")
        
        # Get the tables
        tables = []
        print(f"Table declarations: {ctx.tableDeclaration() if ctx and hasattr(ctx, 'tableDeclaration') else 'None'}")
        
        # Debug the table declarations
        if ctx and hasattr(ctx, 'tableDeclaration') and ctx.tableDeclaration():
            print(f"Number of table declarations: {len(ctx.tableDeclaration())}")
            for i, table_ctx in enumerate(ctx.tableDeclaration()):
                print(f"Table declaration {i}: {table_ctx}")
                if hasattr(table_ctx, 'ID'):
                    print(f"Table name: {table_ctx.ID().getText() if table_ctx.ID() else 'No ID'}")
                else:
                    print("Table context has no ID attribute")
                
                table = self.visitTableDeclaration(table_ctx)
                print(f"Processed table: {table}")
                tables.append(table)
        else:
            print("No table declarations found")
        
        print(f"Tables after processing: {tables}")
        print(f"Types after processing: {types}")
        
        # Create a schema node with the parsed information
        schema_node = SchemaNode(
            node_type=NodeType.SCHEMA,
            name=schema_name,
            types=types,
            tables=tables,
            line=ctx.start.line if ctx and hasattr(ctx, 'start') else 0,
            column=ctx.start.column if ctx and hasattr(ctx, 'start') else 0
        )
        
        print(f"Schema after visiting: {schema_node}")
        print(f"Schema tables: {schema_node.tables}")
        print(f"Schema types: {schema_node.types}")
        
        return schema_node
    
    def visitTableDeclaration(self, ctx: TestDataGenParser.TableDeclarationContext) -> TableNode:
        """Visit a table declaration"""
        # Get the table name
        table_name = ctx.ID().getText()
        
        # Get the fields
        fields = []
        for field_ctx in ctx.fieldDeclaration():
            fields.append(self.visitFieldDeclaration(field_ctx))
        
        # Get the constraints
        constraints = []
        for constraint_ctx in ctx.tableConstraint():
            constraints.append(self.visitTableConstraint(constraint_ctx))
            
        # Get generation directive if present
        generation_options = None
        if ctx.generationDirective():
            generation_directive = self.visitGenerationDirective(ctx.generationDirective())
            if isinstance(generation_directive, dict) and "parameters" in generation_directive:
                generation_options = generation_directive["parameters"]
            else:
                print(f"Invalid generation directive format: {generation_directive}")
                generation_options = {}
            
        # Debug output
        print(f"Table {table_name} has {len(fields)} fields, {len(constraints)} constraints")
        if generation_options:
            print(f"Table {table_name} has generation options: {generation_options}")
        
        return TableNode(
            node_type=NodeType.TABLE,
            name=table_name,
            fields=fields,
            constraints=constraints,
            generation_options=generation_options,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitFieldDeclaration(self, ctx: TestDataGenParser.FieldDeclarationContext) -> FieldNode:
        """Visit a field declaration"""
        # Get the field name
        field_name = ctx.ID().getText()
        
        # Get the data type
        data_type = self.visitDataType(ctx.dataType())
        
        # Get modifiers
        nullable = True
        default_value = None
        
        for modifier_ctx in ctx.fieldModifier():
            if modifier_ctx.NULL():
                nullable = True
            elif modifier_ctx.NOT_NULL():
                nullable = False
            elif modifier_ctx.DEFAULT():
                default_value = self.visitDefaultValue(modifier_ctx.defaultValue())
        
        # Get constraints
        constraints = []
        for constraint_ctx in ctx.fieldConstraint():
            constraints.append(self.visitFieldConstraint(constraint_ctx))
        
        return FieldNode(
            node_type=NodeType.FIELD,
            name=field_name,
            data_type=data_type,
            nullable=nullable,
            default_value=default_value,
            constraints=constraints,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitTypeDeclaration(self, ctx: TestDataGenParser.TypeDeclarationContext) -> TypeNode:
        """Visit a type declaration"""
        # Get the type name
        type_name = ctx.ID().getText()
        
        # Get the base data type
        base_type = self.visitDataType(ctx.dataType())
        
        # Get constraints
        constraints = []
        if hasattr(ctx, 'typeConstraint'):
            for constraint_ctx in ctx.typeConstraint():
                constraint = self.visitTypeConstraint(constraint_ctx)
                constraints.append(constraint)
        
        return TypeNode(
            node_type=NodeType.TYPE,
            name=type_name,
            base_type=base_type,
            constraints=constraints,
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitTypeConstraint(self, ctx: TestDataGenParser.TypeConstraintContext) -> ConstraintNode:
        """Visit a type constraint"""
        constraint_expr = self.visitConstraintExpression(ctx.constraintExpression())
        
        return ConstraintNode(
            node_type=NodeType.CONSTRAINT,
            name=constraint_expr.get("name", "unnamed_constraint"),
            constraint_type=constraint_expr.get("type", "unknown"),
            parameters=constraint_expr.get("parameters", {}),
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitDataType(self, ctx: TestDataGenParser.DataTypeContext) -> str:
        """Visit a data type"""
        if ctx.primitiveType():
            return self.visitPrimitiveType(ctx.primitiveType())
        elif ctx.complexType():
            return self.visitComplexType(ctx.complexType())
        else:
            # Custom type reference
            return ctx.ID().getText()
    
    def visitPrimitiveType(self, ctx: TestDataGenParser.PrimitiveTypeContext) -> str:
        """Visit a primitive type"""
        # Return the text of the primitive type
        return ctx.getText()
    
    def visitComplexType(self, ctx: TestDataGenParser.ComplexTypeContext) -> str:
        """Visit a complex type"""
        # Get the base type
        base_type = self.visitPrimitiveType(ctx.primitiveType())
        
        # Check for array size
        if ctx.INT_LITERAL():
            size = ctx.INT_LITERAL().getText()
            return f"{base_type}[{size}]"
        else:
            return f"{base_type}[]"
    
    def visitDefaultValue(self, ctx: TestDataGenParser.DefaultValueContext) -> Any:
        """Visit a default value"""
        if ctx.literal():
            return self.visitLiteral(ctx.literal())
        else:
            # Function call
            return self.visitFunctionCall(ctx.functionCall())
    
    def visitLiteral(self, ctx: TestDataGenParser.LiteralContext) -> Any:
        """Visit a literal"""
        if ctx.INT_LITERAL():
            return int(ctx.INT_LITERAL().getText())
        elif ctx.DECIMAL_LITERAL():
            return float(ctx.DECIMAL_LITERAL().getText())
        elif ctx.STRING_LITERAL():
            # Remove quotes
            return ctx.STRING_LITERAL().getText()[1:-1]
        elif ctx.TRUE():
            return True
        elif ctx.FALSE():
            return False
        elif ctx.NULL():
            return None
        elif ctx.arrayLiteral():
            return self.visitArrayLiteral(ctx.arrayLiteral())
        elif ctx.objectLiteral():
            return self.visitObjectLiteral(ctx.objectLiteral())
    
    def visitArrayLiteral(self, ctx: TestDataGenParser.ArrayLiteralContext) -> List[Any]:
        """Visit an array literal"""
        values = []
        for literal_ctx in ctx.literal():
            values.append(self.visitLiteral(literal_ctx))
        return values
    
    def visitObjectLiteral(self, ctx: TestDataGenParser.ObjectLiteralContext) -> Dict[str, Any]:
        """Visit an object literal"""
        obj = {}
        for field_ctx in ctx.objectField():
            field_name = field_ctx.ID().getText()
            field_value = self.visitLiteral(field_ctx.literal())
            obj[field_name] = field_value
        return obj
    
    def visitFunctionCall(self, ctx: TestDataGenParser.FunctionCallContext) -> Dict[str, Any]:
        """Visit a function call"""
        function_name = ctx.ID().getText()
        
        # Get arguments
        args = []
        if ctx.functionArgs():
            for arg_ctx in ctx.functionArgs().functionArg():
                args.append(self.visitExpression(arg_ctx.expression()))
        
        return {
            "function": function_name,
            "args": args
        }
    
    def visitExpression(self, ctx: TestDataGenParser.ExpressionContext) -> Any:
        """Visit an expression"""
        # This is a simplified implementation
        # In a real implementation, we would build an expression tree
        
        # For now, just return a placeholder
        return {"expression": ctx.getText()}
    
    def visitFieldConstraint(self, ctx: TestDataGenParser.FieldConstraintContext) -> ConstraintNode:
        """Visit a field constraint"""
        constraint_expr = self.visitConstraintExpression(ctx.constraintExpression())
        
        return ConstraintNode(
            node_type=NodeType.CONSTRAINT,
            name=constraint_expr.get("name", "unnamed_constraint"),
            constraint_type=constraint_expr.get("type", "unknown"),
            parameters=constraint_expr.get("parameters", {}),
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitTableConstraint(self, ctx: TestDataGenParser.TableConstraintContext) -> ConstraintNode:
        """Visit a table constraint"""
        # Get constraint name if provided
        constraint_name = "unnamed_constraint"
        if ctx.ID():
            constraint_name = ctx.ID().getText()
        
        constraint_expr = self.visitConstraintExpression(ctx.constraintExpression())
        
        return ConstraintNode(
            node_type=NodeType.CONSTRAINT,
            name=constraint_name,
            constraint_type=constraint_expr.get("type", "unknown"),
            parameters=constraint_expr.get("parameters", {}),
            line=ctx.start.line,
            column=ctx.start.column
        )
    
    def visitConstraintExpression(self, ctx: TestDataGenParser.ConstraintExpressionContext) -> Dict[str, Any]:
        """Visit a constraint expression"""
        if ctx.primaryKeyConstraint():
            return self.visitPrimaryKeyConstraint(ctx.primaryKeyConstraint())
        elif ctx.foreignKeyConstraint():
            return self.visitForeignKeyConstraint(ctx.foreignKeyConstraint())
        elif ctx.uniqueConstraint():
            return self.visitUniqueConstraint(ctx.uniqueConstraint())
        elif ctx.checkConstraint():
            return self.visitCheckConstraint(ctx.checkConstraint())
        elif ctx.generationDirective():
            return self.visitGenerationDirective(ctx.generationDirective())
        else:
            return {"type": "unknown"}
    
    def visitPrimaryKeyConstraint(self, ctx: TestDataGenParser.PrimaryKeyConstraintContext) -> Dict[str, Any]:
        """Visit a primary key constraint"""
        fields = self.visitIdList(ctx.idList())
        
        return {
            "type": "primary_key",
            "parameters": {
                "fields": fields
            }
        }
    
    def visitForeignKeyConstraint(self, ctx: TestDataGenParser.ForeignKeyConstraintContext) -> Dict[str, Any]:
        """Visit a foreign key constraint"""
        source_fields = self.visitIdList(ctx.idList(0))
        target_table = ctx.ID().getText()
        target_fields = self.visitIdList(ctx.idList(1))
        
        return {
            "type": "foreign_key",
            "parameters": {
                "source_fields": source_fields,
                "target_table": target_table,
                "target_fields": target_fields
            }
        }
    
    def visitUniqueConstraint(self, ctx: TestDataGenParser.UniqueConstraintContext) -> Dict[str, Any]:
        """Visit a unique constraint"""
        fields = self.visitIdList(ctx.idList())
        
        return {
            "type": "unique",
            "parameters": {
                "fields": fields
            }
        }
    
    def visitCheckConstraint(self, ctx: TestDataGenParser.CheckConstraintContext) -> Dict[str, Any]:
        """Visit a check constraint"""
        expression = self.visitExpression(ctx.expression())
        
        return {
            "type": "check",
            "parameters": {
                "expression": expression
            }
        }
    
    def visitIdList(self, ctx: TestDataGenParser.IdListContext) -> List[str]:
        """Visit an ID list"""
        return [id_node.getText() for id_node in ctx.ID()]
        
    def visitGenerationDirective(self, ctx: TestDataGenParser.GenerationDirectiveContext) -> Dict[str, Any]:
        """Visit a generation directive"""
        options = self.visitGenerationOptions(ctx.generationOptions())
        
        return {
            "type": "generate",
            "name": "generation_directive",
            "parameters": options
        }
        
    def visitGenerationOptions(self, ctx: TestDataGenParser.GenerationOptionsContext) -> Dict[str, Any]:
        """Visit generation options"""
        options = {}
        
        for option_ctx in ctx.generationOption():
            option_name = option_ctx.ID().getText()
            option_value = self.visitGenerationValue(option_ctx.generationValue())
            options[option_name] = option_value
            
        return options
        
    def visitGenerationValue(self, ctx: TestDataGenParser.GenerationValueContext) -> Any:
        """Visit a generation value"""
        if ctx.literal():
            return self.visitLiteral(ctx.literal())
        elif ctx.functionCall():
            return self.visitFunctionCall(ctx.functionCall())
        else:
            return None
